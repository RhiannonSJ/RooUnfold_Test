//=====================================================================-*-C++-*-
// File and Version Information:
//      $Id: RooUnfoldTestHarness3D.icc,v 1.8 2010-01-21 20:05:14 adye Exp $
//
// Description:
//      Harness class to test the RooUnfold package using 3D toy MC generated
//      according to PDFs defined in RooUnfoldTestPdf.icc or RooUnfoldTestPdfRooFit.icc.
//
// Author: Tim Adye <T.J.Adye@rl.ac.uk>
//
//==============================================================================

#ifndef ROOUNFOLDTESTHARNESS3D_ICC
#define ROOUNFOLDTESTHARNESS3D_ICC

#include "RooUnfoldTestHarness3D.h"

#if !defined(__CINT__) || defined(__MAKECINT__)
#include <iostream>

#include "TROOT.h"
#include "TCanvas.h"
#include "TH1D.h"
#include "TH3D.h"
#include "TVectorD.h"

#include "RooUnfoldResponse.h"
#endif

#include "ArgVars.h"

#if !defined(__CINT__) || defined(__MAKECINT__)
using std::cerr;
using std::endl;
#endif

//==============================================================================
// Gaussian smearing, systematic translation, and variable inefficiency
//==============================================================================

bool RooUnfoldTestHarness3D::Eff3D (Double_t x, Double_t y, Double_t z) const
{
  return Eff (x, xlo, xhi, effxlo, effxhi) &&
         Eff (y, ylo, yhi, effylo, effyhi) &&
         Eff (z, zlo, zhi, effzlo, effzhi);
}

void RooUnfoldTestHarness3D::Smear3D (Double_t& x, Double_t& y, Double_t& z) const
{
  if (!dosmear) return;
  x= Smear (x, ntx, xlo, xhi, xbias, xsmear);
  y= Smear (y, nty, ylo, yhi, ybias, ysmear);
  z= Smear (z, ntz, zlo, zhi, zbias, zsmear);
  Rot (x, y, rotxy, 0.5*(xlo+xhi), 0.5*(ylo+yhi));
  Rot (x, z, rotxz, 0.5*(xlo+xhi), 0.5*(zlo+zhi));
  Rot (y, z, rotyz, 0.5*(ylo+yhi), 0.5*(zlo+zhi));
}

TH1D* RooUnfoldTestHarness3D::Projection3D (const TH1* h, Option_t* xyz, const char* name, const char* title, Option_t* opt)
{
  const TH3* h3= dynamic_cast<const TH3*>(h);
  TString opts (xyz);
  opts += opt;
  TH1D* h1= dynamic_cast<TH1D*>(h3->Project3D (opts));
  if (h1 && name)  h1->SetName  (name);
  if (h1 && title) h1->SetTitle (title);
  return h1;
}

//==============================================================================
// Train unfolding algorithm
//==============================================================================

Int_t RooUnfoldTestHarness3D::Train()
{
  TVectorD xtrue(ntrain), ytrue(ntrain), ztrue(ntrain);

  hPDFx= Generate (xtrue, "trainpdfx", "Training PDF X", ntx, ftrainx, ntrain, xlo, xhi, mtrainx, wtrainx, btrainx);
  if (!hPDFx) return 0;
  hPDFy= Generate (ytrue, "trainpdfy", "Training PDF Y", nty, ftrainy, ntrain, ylo, yhi, mtrainy, wtrainy, btrainy);
  if (!hPDFy) return 0;
  hPDFz= Generate (ztrue, "trainpdfz", "Training PDF Z", ntz, ftrainz, ntrain, zlo, zhi, mtrainz, wtrainz, btrainz);
  if (!hPDFz) return 0;

  hTrainTrue= new TH3D ("traintrue", "Training Truth", ntx, xlo, xhi, nty, ylo, yhi, ntz, zlo, zhi);
  hTrainTrue->SetLineColor(kBlue);
  hTrain= new TH3D ("train", "Training Measured", nmx, xlo, xhi, nmy, ylo, yhi, nmz, zlo, zhi);
  hTrain->SetLineColor(kRed);

  response->Setup (hTrain, hTrainTrue);

  for (Int_t i= 0; i<ntrain; i++) {
    Double_t xt= xtrue[i], yt= ytrue[i], zt= ztrue[i];
    Fill (hTrainTrue, xt, yt, zt);

    if (Eff3D (xt, yt, zt)) {
      Double_t x= xt, y= yt, z= zt;
      Smear3D (x, y, z);
      Fill (hTrain, x, y, z);
      response->Fill (x, y, z, xt, yt, zt);
    } else {
      response->Miss (xt, yt, zt);
    }
  }

  hTrainTrueX= ProjectionX (hTrainTrue, "hTrainTrueX", "Training X");
  hTrainTrueY= ProjectionY (hTrainTrue, "hTrainTrueY", "Training Y");
  hTrainTrueZ= ProjectionZ (hTrainTrue, "hTrainTrueZ", "Training Z");

  hTrainX=     ProjectionX (hTrain,     "hTrainX",     "Training Measured X");
  hTrainY=     ProjectionY (hTrain,     "hTrainY",     "Training Measured Y");
  hTrainZ=     ProjectionZ (hTrain,     "hTrainZ",     "Training Measured Z");

  setmax (hTrainTrueX, hPDFx, hTrainX);
  setmax (hTrainTrueY, hPDFy, hTrainY);
  setmax (hTrainTrueZ, hPDFz, hTrainZ);

  canvas->cd(1);
  hTrainTrueX->Draw();
  hPDFx      ->Draw("LSAME");
  hTrainX    ->Draw("SAME");

  canvas->cd(2);
  hTrainTrueY->Draw();
  hPDFy      ->Draw("LSAME");
  hTrainY    ->Draw("SAME");

  canvas->cd(3);
  hTrainTrueZ->Draw();
  hPDFz      ->Draw("LSAME");
  hTrainZ    ->Draw("SAME");

  canvas->Update();

  return 1;
}

//==============================================================================
// Test unfolding algorithm
//==============================================================================

Int_t RooUnfoldTestHarness3D::Test()
{
  TVectorD xtest(ntest), ytest(ntest), ztest(ntest);

  hTestPDFx= Generate (xtest, "pdfx", "PDF X", ntx, ftestx, ntest, xlo, xhi, mtestx, wtestx, btestx);
  if (!hTestPDFx) return 0;
  hTestPDFy= Generate (ytest, "pdfy", "PDF Y", nty, ftesty, ntest, ylo, yhi, mtesty, wtesty, btesty);
  if (!hTestPDFy) return 0;
  hTestPDFz= Generate (ztest, "pdfz", "PDF Z", ntz, ftestz, ntest, zlo, zhi, mtestz, wtestz, btestz);
  if (!hTestPDFz) return 0;

  hTrue= new TH3D ("true", "Test Truth", ntx, xlo, xhi, nty, ylo, yhi, ntz, zlo, zhi);
  hTrue->SetLineColor(kBlue);
  hMeas= new TH3D ("meas", "Test Measured", nmx, xlo, xhi, nmy, ylo, yhi, nmz, zlo, zhi);
  hMeas->SetLineColor(kRed);

  for (Int_t i=0; i<ntest ; i++) {
    Double_t xt= xtest[i], yt= ytest[i], zt= ztest[i];
    Fill (hTrue, xt, yt, zt);
    if (Eff3D (xt, yt, zt)) {
      Double_t x= xt, y= yt, z= zt;
      Smear3D (x, y, z);
      Fill (hMeas, x, y, z);
    }
  }

  hTrueX= ProjectionX (hTrue, "hTrueX", "Test X");
  hMeasX= ProjectionX (hMeas, "hMeasX", "Test Measured X");
  hTrueY= ProjectionY (hTrue, "hTrueY", "Test Y");
  hMeasY= ProjectionY (hMeas, "hMeasY", "Test Measured Y");
  hTrueZ= ProjectionZ (hTrue, "hTrueZ", "Test Z");
  hMeasZ= ProjectionZ (hMeas, "hMeasZ", "Test Measured Z");

  return 1;
}

//==============================================================================
// Show results
//==============================================================================

void RooUnfoldTestHarness3D::ShowTest()
{
  setmax (hTrueX, hTestPDFx, hMeasX);
  setmax (hTrueY, hTestPDFy, hMeasY);
  setmax (hTrueZ, hTestPDFz, hMeasZ);

  canvas->cd(4);
  hTrueX   ->Draw();
  hTestPDFx->Draw("LSAME");
  hMeasX   ->Draw("SAME");

  canvas->cd(5);
  hTrueY   ->Draw();
  hTestPDFy->Draw("LSAME");
  hMeasY   ->Draw("SAME");

  canvas->cd(6);
  hTrueZ   ->Draw();
  hTestPDFz->Draw("LSAME");
  hMeasZ   ->Draw("SAME");

  canvas->cd(7);
  hTrue->Draw();

  canvas->cd(8);
  hMeas->Draw();
}

void RooUnfoldTestHarness3D::Results()
{
  hRecoX= ProjectionX (hReco, "hRecoX", "Reconstructed X", "E");
  hRecoY= ProjectionY (hReco, "hRecoY", "Reconstructed Y", "E");
  hRecoZ= ProjectionZ (hReco, "hRecoZ", "Reconstructed Z", "E");
  hRecoX->SetMarkerStyle(8);
  hRecoY->SetMarkerStyle(8);
  hRecoZ->SetMarkerStyle(8);
  setmax (hTrueX, hRecoX);
  setmax (hTrueY, hRecoY);
  setmax (hTrueZ, hRecoZ);
  ShowTest();

  canvas->cd(4);
  hRecoX   ->Draw("SAME");

  canvas->cd(5);
  hRecoY   ->Draw("SAME");

  canvas->cd(6);
  hRecoZ   ->Draw("SAME");

  canvas->cd(9);
  hReco->Draw();

  canvas->Update();
}

Int_t RooUnfoldTestHarness3D::CheckParms()
{
  RooUnfoldTestHarness2D::CheckParms();
  if (nmz<=0)     {cerr << "Error: nmz ("    << nmz    << ") <= 0"                  << endl; error = 2;}
  if (ntz<=0)     {cerr << "Error: ntz ("    << ntz    << ") <= 0"                  << endl; error = 2;}
  if (zlo >= zhi) {cerr << "Error: zlo ("    << zlo    << ") >= zhi(" << zhi << ")" << endl; error = 2;}
  if (ftrainz<0)  {cerr << "Error: ftrainz ("<< ftrainz<< ") < 0"                   << endl; error = 2;}
  if (ftestz<0)   {cerr << "Error: ftestz (" << ftestz << ") < 0"                   << endl; error = 2;}
  return error;
}

void RooUnfoldTestHarness3D::Init()
{
  RooUnfoldTestHarness2D::Init();
  if (ntz==-1) ntz= nty;
  if (nmz==-1) nmz= ntz;
  ntbins= ntx*nty*ntz;
  nmbins= nmx*nmy*nmz;
}

//==============================================================================
// Constructor
//==============================================================================

RooUnfoldTestHarness3D::RooUnfoldTestHarness3D (const char* name)
  : RooUnfoldTestHarness2D(name)
{
  Reset();
  SetDefaults();
}

RooUnfoldTestHarness3D::RooUnfoldTestHarness3D (const char* name, int argc, const char* const* argv)
  : RooUnfoldTestHarness2D(name)
{
  Reset();
  error= SetArgs (argc, argv);
}

RooUnfoldTestHarness3D::RooUnfoldTestHarness3D (const char* name, const char* args)
  : RooUnfoldTestHarness2D(name)
{
  Reset();
  const char* const argv[]= { name, args };
  error= SetArgs (2, argv, true);
}

void RooUnfoldTestHarness3D::Reset()
{
  RooUnfoldTestHarness2D::Reset();
  hTrainZ= hTrainTrueZ= hTrueZ= hMeasZ= hRecoZ= hPDFz= hTestPDFz= 0;
  dim= 3;
}

void RooUnfoldTestHarness3D::Parms (ArgVars& args)
{
  RooUnfoldTestHarness2D::Parms (args);
  args.SetDefault ("onepage", 10);
  args.SetDefault ("ntx",     10);
  args.SetDefault ("nty",      5);
  args.SetDefault ("ftestx",   2);
  args.Add ("ftrainz", &ftrainz,      0, "training Z PDF");
  args.Add ("ftestz",  &ftestz,       6, "test Z PDF");
  args.Add ("ntz",     &ntz,          5, "#truth Z bins");
  args.Add ("nmz",     &nmz,         -1, "#measured Z bins", "ntz");
  args.Add ("zlo",     &zlo,        0.0, "Z range minimum");
  args.Add ("zhi",     &zhi,       10.0, "Z range maximum");
  args.Add ("mtrainz", &mtrainz,    5.0, "training signal PDF Z mean");
  args.Add ("wtrainz", &wtrainz,    1.0, "training signal PDF Z width");
  args.Add ("btrainz", &btrainz,    0.2, "training Z PDF background fraction");
  args.Add ("mtestz",  &mtestz,     4.0, "test signal PDF Z mean");
  args.Add ("wtestz",  &wtestz,     1.5, "test signal PDF Z width");
  args.Add ("btestz",  &btestz,     0.3, "test Z PDF background fraction");
  args.Add ("effzlo",  &effzlo,     0.9, "efficiencz at zlo");
  args.Add ("effzhi",  &effzhi,     1.0, "efficiencz at zhi");
  args.Add ("rotxz",   &rotxz,      0.4, "rotation angle in XZ plane");
  args.Add ("rotyz",   &rotyz,      0.4, "rotation angle in YZ plane");
  args.Add ("zbias",   &zbias,     -1.0, "shift in Z");
  args.Add ("zsmear",  &zsmear,     0.5, "Z smearing width in bins");
}

#endif
