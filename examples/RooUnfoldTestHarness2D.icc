//=====================================================================-*-C++-*-
// File and Version Information:
//      $Id: RooUnfoldTestHarness2D.icc,v 1.6 2010-01-19 23:30:57 adye Exp $
//
// Description:
//      Harness class to test the RooUnfold package using 2D toy MC generated
//      according to PDFs defined in RooUnfoldTestPdf.icc or RooUnfoldTestPdfRooFit.icc.
//
// Author: Tim Adye <T.J.Adye@rl.ac.uk>
//
//==============================================================================

#ifndef ROOUNFOLDTESTHARNESS2D_ICC
#define ROOUNFOLDTESTHARNESS2D_ICC

#include "RooUnfoldTestHarness2D.h"

#include "RooUnfoldTestHarness.icc"

#if !defined(__CINT__) || defined(__MAKECINT__)
#include "TH2D.h"
#endif

//==============================================================================
// Gaussian smearing, systematic translation, and variable inefficiency
//==============================================================================

void RooUnfoldTestHarness2D::rot (Double_t& x, Double_t& y)
{
  Double_t a= gRandom->Gaus (0.25, 0.05);
  if      (a<0.0) a= 0.0;
  else if (a>1.0) a= 1.0;
  Double_t b= 1.0-a;
  Double_t xr= a*x + b*y;
  Double_t yr= b*x + a*y;
  x= xr;
  y= yr;
}

Bool_t RooUnfoldTestHarness2D::smear (Double_t& x, Double_t& y,
                                      Int_t nx, Double_t xlo, Double_t xhi,
                                      Int_t ny, Double_t ylo, Double_t yhi)
{
  Double_t xs= smear (x, nx, xlo, xhi);
  if (xs==cutdummy) return false;
  Double_t ys= smear (y, ny, ylo, yhi);
  if (ys==cutdummy) return false;
  x= xs;
  y= ys;
  if (!nosmear) rot (x, y);
  return true;
}

//==============================================================================
// Train unfolding algorithm
//==============================================================================

Int_t RooUnfoldTestHarness2D::Train ()
{
  TVectorD xtrue(ntrain), ytrue(ntrain);

  hPDFx= Generate (xtrue, "trainpdfx", "Training PDF X", ntx, ftrainx, ntrain, xlo, xhi, bkgtx);
  if (!hPDFx) return 0;
  hPDFy= Generate (ytrue, "trainpdfy", "Training PDF Y", nty, ftrainy, ntrain, ylo, yhi, bkgty);
  if (!hPDFy) return 0;

  hTrainTrue= new TH2D ("traintrue", "Training Truth", ntx, xlo, xhi, nty, ylo, yhi);
  hTrainTrue->SetLineColor(kBlue);
  hTrain= new TH2D ("train", "Training Measured", nmx, xlo, xhi, nmy, ylo, yhi);
  hTrain->SetLineColor(kRed);

  response->Setup (hTrain, hTrainTrue);

  for (Int_t i= 0; i<ntrain; i++) {
    Double_t xt= xtrue[i], yt= ytrue[i];
    hTrainTrue->Fill (xt, yt);

    Double_t x= xt, y= yt;
    if (smear (x, y, ntx, xlo, xhi, nty, ylo, yhi)) {
      hTrain ->Fill (x, y);
      response->Fill (x, y, xt, yt);
    } else {
      response->Miss (xt, yt);
    }
  }

  hTrainTrueX= ProjectionX (hTrainTrue, "hTrainTrueX", "Training X");
  hTrainTrueY= ProjectionY (hTrainTrue, "hTrainTrueY", "Training Y");
  hTrainX=     ProjectionX (hTrain,     "hTrainX",     "Training Measured X");
  hTrainY=     ProjectionY (hTrain,     "hTrainY",     "Training Measured Y");

  setmax (hTrainTrueX, hPDFx, hTrainX);
  setmax (hTrainTrueY, hPDFy, hTrainY);

  canvas->cd(1);
  hTrainTrueX->Draw();
  hPDFx      ->Draw("LSAME");
  hTrainX    ->Draw("SAME");

  canvas->cd(2);
  hTrainTrueY->Draw();
  hPDFy      ->Draw("LSAME");
  hTrainY    ->Draw("SAME");

  canvas->Update();

  return 1;
}

//==============================================================================
// Test unfolding algorithm
//==============================================================================

Int_t RooUnfoldTestHarness2D::Test ()
{
  TVectorD xtest(ntest), ytest(ntest);

  hTestPDFx= Generate (xtest, "pdfx", "PDF X", ntx, ftestx, ntest, xlo, xhi, bkgex, 1.0, 2.5);
  if (!hTestPDFx) return 0;
  hTestPDFy= Generate (ytest, "pdfy", "PDF Y", nty, ftesty, ntest, ylo, yhi, bkgey, -0.5, 2.5);
  if (!hTestPDFy) return 0;

  hTrue= new TH2D ("true", "Test Truth", ntx, xlo, xhi, nty, ylo, yhi);
  hTrue->SetLineColor(kBlue);
  hMeas= new TH2D ("meas", "Test Measured", nmx, xlo, xhi, nmy, ylo, yhi);
  hMeas->SetLineColor(kRed);

  for (Int_t i=0; i<ntest ; i++) {
    Double_t xt= xtest[i], yt= ytest[i];
    hTrue->Fill (xt, yt);
    Double_t x= xt, y= yt;
    if (smear (x, y, ntx, xlo, xhi, nty, ylo, yhi))
      hMeas->Fill (x, y);
  }

  hTrueX= ProjectionX (hTrue, "hTrueX", "Test X");
  hTrueY= ProjectionY (hTrue, "hTrueY", "Test Y");
  hMeasX= ProjectionX (hMeas, "hMeasX", "Test Measured X");
  hMeasY= ProjectionY (hMeas, "hMeasY", "Test Measured Y");

  return 1;
}

//==============================================================================
// Show results
//==============================================================================

void RooUnfoldTestHarness2D::Results()
{
  hRecoX= ProjectionX (hReco, "hRecoX", "Reconstructed X", "E");
  hRecoY= ProjectionY (hReco, "hRecoY", "Reconstructed Y", "E");
  hRecoX->SetMarkerStyle(8);
  hRecoY->SetMarkerStyle(8);

  setmax (hTrueX, hTestPDFx, hMeasX, hRecoX);
  setmax (hTrueY, hTestPDFy, hMeasY, hRecoY);

  canvas->cd(3);
  hTrueX   ->Draw();
  hTestPDFx->Draw("LSAME");
  hMeasX   ->Draw("SAME");
  hRecoX   ->Draw("SAME");

  canvas->cd(4);
  hTrueY   ->Draw();
  hTestPDFy->Draw("LSAME");
  hMeasY   ->Draw("SAME");
  hRecoY   ->Draw("SAME");

  canvas->cd(5);
  hTrue->Draw();

  canvas->cd(6);
  hMeas->Draw();

  canvas->cd(7);
  hReco->Draw();

  // I think hReco already includes the statistical error on hTrue, so
  // don't include that twice when calculating residuals.
  hRes= new TH2D ("res", "Pull (reco-true)/error", ntx, xlo, xhi, nty, ylo, yhi);
  for (Int_t i= 0; i <= ntx+1; i++) {
    for (Int_t j= 0; j <= nty+1; j++) {
      Double_t rec= hReco->GetBinContent (i, j);
      Double_t tru= hTrue->GetBinContent (i, j);
      Double_t err= hReco->GetBinError   (i, j);
      if      (err > 0)
        hRes->SetBinContent (i, j, (rec-tru)/err);
      else if (rec > 0)
        hRes->SetBinContent (i, j, (rec-tru)/sqrt(rec));
    }
  }

  canvas->cd(8);
  hRes->Draw("COLZ");
  canvas->Update();
}

Int_t RooUnfoldTestHarness2D::Check()
{
  RooUnfoldTestHarness::Check();
  if (nmy<=0)     {cout << "Error: nmy ("    << nmy    << ") <= 0"                  << endl; error = 2;}
  if (nty<=0)     {cout << "Error: nty ("    << nty    << ") <= 0"                  << endl; error = 2;}
  if (ylo >= yhi) {cout << "Error: ylo ("    << ylo    << ") >= yhi(" << yhi << ")" << endl; error = 2;}
  if (ftrainy<1)  {cout << "Error: ftrainy ("<< ftrainy<< ") < 1"                   << endl; error = 2;}
  if (ftesty<1)   {cout << "Error: ftesty (" << ftesty << ") < 1"                   << endl; error = 2;}
  return error;
}

void RooUnfoldTestHarness2D::Init()
{
  RooUnfoldTestHarness::Init();
  if (nty==-1) nty= ntx;
  if (nmy==-1) nmy= nty;
  if (bkgty==-1.0) bkgty= bkgtx;
  if (bkgey==-1.0) bkgey= bkgex;
  ntbins= ntx*nty;
  nmbins= nmx*nmy;
}

//==============================================================================
// Constructor
//==============================================================================

RooUnfoldTestHarness2D::RooUnfoldTestHarness2D (const char* name)
  : RooUnfoldTestHarness(name)
{
  Reset();
  SetDefaults();
}

RooUnfoldTestHarness2D::RooUnfoldTestHarness2D (const char* name, int argc, const char* const* argv)
  : RooUnfoldTestHarness(name)
{
  Reset();
  error= SetArgs (argc, argv);
}

RooUnfoldTestHarness2D::RooUnfoldTestHarness2D (const char* name, const char* args)
{
  Reset();
  const char* const argv[]= { name, args };
  error= SetArgs (2, argv, true);
}

void RooUnfoldTestHarness2D::Reset()
{
  RooUnfoldTestHarness::Reset();
  hTrainX= hTrainTrueX= hTrueX= hMeasX= hRecoX=
  hTrainY= hTrainTrueY= hTrueY= hMeasY= hRecoY= hPDFy= hTestPDFy= 0;
  dim= 2;
}

void RooUnfoldTestHarness2D::Parms (ArgVars& args)
{
  RooUnfoldTestHarness::Parms (args);
  args.SetDefault ("ftrainx", 1);
  args.SetDefault ("ftestx",  3);
  args.SetDefault ("onepage", 8);
  args.Add ("ftrainy", &ftrainy,     1, "training Y PDF");
  args.Add ("ftesty",  &ftesty ,     5, "test Y PDF");
  args.Add ("nty",     &nty,        -1, "#truth Y bins", "ntx");
  args.Add ("nmy",     &nmy,        -1, "#measured Y bins", "nty");
  args.Add ("ylo",     &ylo,     -12.5, "Y range minimum");
  args.Add ("yhi",     &yhi,      10.0, "Y range maximum");
  args.Add ("bkgty",   &bkgty,    -1.0, "background fraction for training Y PDF", "bkgtx");
  args.Add ("bkgey",   &bkgey,    -1.0, "background fraction for test Y PDF", "bkgex");
}

#endif
