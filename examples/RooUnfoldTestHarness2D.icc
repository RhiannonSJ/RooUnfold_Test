//=====================================================================-*-C++-*-
// File and Version Information:
//      $Id: RooUnfoldTestHarness2D.icc,v 1.11 2010-01-21 20:05:14 adye Exp $
//
// Description:
//      Harness class to test the RooUnfold package using 2D toy MC generated
//      according to PDFs defined in RooUnfoldTestPdf.icc or RooUnfoldTestPdfRooFit.icc.
//
// Author: Tim Adye <T.J.Adye@rl.ac.uk>
//
//==============================================================================

#ifndef ROOUNFOLDTESTHARNESS2D_ICC
#define ROOUNFOLDTESTHARNESS2D_ICC

#include "RooUnfoldTestHarness2D.h"

#if !defined(__CINT__) || defined(__MAKECINT__)
#include <cmath>
#include <iostream>

#include "TROOT.h"
#include "TCanvas.h"
#include "TRandom.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TVectorD.h"

#include "RooUnfoldResponse.h"
#endif

#include "ArgVars.h"

#if !defined(__CINT__) || defined(__MAKECINT__)
using std::cerr;
using std::endl;
using std::sin;
using std::cos;
#endif

//==============================================================================
// Gaussian smearing, systematic translation, and variable inefficiency
//==============================================================================

void RooUnfoldTestHarness2D::Rot (Double_t& x, Double_t& y, Double_t angle, Double_t x0, Double_t y0)
{
  if (angle==0.0) return;
  Double_t a= gRandom->Gaus (angle, 0.2*angle);
  Double_t s= sin(a), c= cos(a);
  Double_t xr= c*(x-x0) - s*(y-y0);
  Double_t yr= s*(x-x0) + c*(y-y0);
  x= x0+xr;
  y= y0+yr;
}

bool RooUnfoldTestHarness2D::Eff2D (Double_t x, Double_t y) const
{
  return Eff (x, xlo, xhi, effxlo, effxhi) &&
         Eff (y, ylo, yhi, effylo, effyhi);
}

void RooUnfoldTestHarness2D::Smear2D (Double_t& x, Double_t& y) const
{
  if (!dosmear) return;
  x= Smear (x, ntx, xlo, xhi, xbias, xsmear);
  y= Smear (y, nty, ylo, yhi, ybias, ysmear);
  Rot (x, y, rotxy, 0.5*(xlo+xhi), 0.5*(ylo+yhi));
  return;
}

//==============================================================================
// Train unfolding algorithm
//==============================================================================

Int_t RooUnfoldTestHarness2D::Train ()
{
  TVectorD xtrue(ntrain), ytrue(ntrain);

  hPDFx= Generate (xtrue, "trainpdfx", "Training PDF X", ntx, ftrainx, ntrain, xlo, xhi, mtrainx, wtrainx, btrainx);
  if (!hPDFx) return 0;
  hPDFy= Generate (ytrue, "trainpdfy", "Training PDF Y", nty, ftrainy, ntrain, ylo, yhi, mtrainy, wtrainy, btrainy);
  if (!hPDFy) return 0;

  hTrainTrue= new TH2D ("traintrue", "Training Truth", ntx, xlo, xhi, nty, ylo, yhi);
  hTrainTrue->SetLineColor(kBlue);
  hTrain= new TH2D ("train", "Training Measured", nmx, xlo, xhi, nmy, ylo, yhi);
  hTrain->SetLineColor(kRed);

  response->Setup (hTrain, hTrainTrue);

  for (Int_t i= 0; i<ntrain; i++) {
    Double_t xt= xtrue[i], yt= ytrue[i];
    hTrainTrue->Fill (xt, yt);
    if (Eff2D (xt, yt)) {
      Double_t x= xt, y= yt;
      Smear2D (x, y);
      hTrain  ->Fill (x, y);
      response->Fill (x, y, xt, yt);
    } else {
      response->Miss (xt, yt);
    }
  }

  hTrainTrueX= ProjectionX (hTrainTrue, "hTrainTrueX", "Training X");
  hTrainTrueY= ProjectionY (hTrainTrue, "hTrainTrueY", "Training Y");
  hTrainX=     ProjectionX (hTrain,     "hTrainX",     "Training Measured X");
  hTrainY=     ProjectionY (hTrain,     "hTrainY",     "Training Measured Y");

  setmax (hTrainTrueX, hPDFx, hTrainX);
  setmax (hTrainTrueY, hPDFy, hTrainY);

  canvas->cd(1);
  hTrainTrueX->Draw();
  hPDFx      ->Draw("LSAME");
  hTrainX    ->Draw("SAME");

  canvas->cd(2);
  hTrainTrueY->Draw();
  hPDFy      ->Draw("LSAME");
  hTrainY    ->Draw("SAME");

  canvas->Update();

  return 1;
}

//==============================================================================
// Test unfolding algorithm
//==============================================================================

Int_t RooUnfoldTestHarness2D::Test ()
{
  TVectorD xtest(ntest), ytest(ntest);

  hTestPDFx= Generate (xtest, "pdfx", "PDF X", ntx, ftestx, ntest, xlo, xhi, mtestx, wtestx, btestx);
  if (!hTestPDFx) return 0;
  hTestPDFy= Generate (ytest, "pdfy", "PDF Y", nty, ftesty, ntest, ylo, yhi, mtesty, wtesty, btesty);
  if (!hTestPDFy) return 0;

  hTrue= new TH2D ("true", "Test Truth", ntx, xlo, xhi, nty, ylo, yhi);
  hTrue->SetLineColor(kBlue);
  hMeas= new TH2D ("meas", "Test Measured", nmx, xlo, xhi, nmy, ylo, yhi);
  hMeas->SetLineColor(kRed);

  for (Int_t i=0; i<ntest ; i++) {
    Double_t xt= xtest[i], yt= ytest[i];
    hTrue->Fill (xt, yt);
    if (Eff2D (xt, yt)) {
      Double_t x= xt, y= yt;
      Smear2D (x, y);
      hMeas->Fill (x, y);
    }
  }

  hTrueX= ProjectionX (hTrue, "hTrueX", "Test X");
  hTrueY= ProjectionY (hTrue, "hTrueY", "Test Y");
  hMeasX= ProjectionX (hMeas, "hMeasX", "Test Measured X");
  hMeasY= ProjectionY (hMeas, "hMeasY", "Test Measured Y");

  return 1;
}

//==============================================================================
// Show results
//==============================================================================

void RooUnfoldTestHarness2D::ShowTest()
{
  setmax (hTrueX, hTestPDFx, hMeasX);
  setmax (hTrueY, hTestPDFy, hMeasY);

  canvas->cd(3);
  hTrueX   ->Draw();
  hTestPDFx->Draw("LSAME");
  hMeasX   ->Draw("SAME");

  canvas->cd(4);
  hTrueY   ->Draw();
  hTestPDFy->Draw("LSAME");
  hMeasY   ->Draw("SAME");

  canvas->cd(5);
  hTrue->Draw();

  canvas->cd(6);
  hMeas->Draw();
}

void RooUnfoldTestHarness2D::Results()
{
  hRecoX= ProjectionX (hReco, "hRecoX", "Reconstructed X", "E");
  hRecoY= ProjectionY (hReco, "hRecoY", "Reconstructed Y", "E");
  hRecoX->SetMarkerStyle(8);
  hRecoY->SetMarkerStyle(8);

  setmax (hTrueX, hRecoX);
  setmax (hTrueY, hRecoY);
  ShowTest();

  canvas->cd(3);
  hRecoX   ->Draw("SAME");

  canvas->cd(4);
  hRecoY   ->Draw("SAME");

  canvas->cd(7);
  hReco->Draw();

  canvas->cd(8);
  hPulls->Draw("COLZ");
  canvas->Update();
}

Int_t RooUnfoldTestHarness2D::CheckParms()
{
  RooUnfoldTestHarness::CheckParms();
  if (nmy<=0)     {cerr << "Error: nmy ("    << nmy    << ") <= 0"                  << endl; error = 2;}
  if (nty<=0)     {cerr << "Error: nty ("    << nty    << ") <= 0"                  << endl; error = 2;}
  if (ylo >= yhi) {cerr << "Error: ylo ("    << ylo    << ") >= yhi(" << yhi << ")" << endl; error = 2;}
  if (ftrainy<0)  {cerr << "Error: ftrainy ("<< ftrainy<< ") < 0"                   << endl; error = 2;}
  if (ftesty<0)   {cerr << "Error: ftesty (" << ftesty << ") < 0"                   << endl; error = 2;}
  return error;
}

void RooUnfoldTestHarness2D::Init()
{
  RooUnfoldTestHarness::Init();
  if (nty==-1) nty= ntx;
  if (nmy==-1) nmy= nty;
  ntbins= ntx*nty;
  nmbins= nmx*nmy;
}

//==============================================================================
// Constructor
//==============================================================================

RooUnfoldTestHarness2D::RooUnfoldTestHarness2D (const char* name)
  : RooUnfoldTestHarness(name)
{
  Reset();
  SetDefaults();
}

RooUnfoldTestHarness2D::RooUnfoldTestHarness2D (const char* name, int argc, const char* const* argv)
  : RooUnfoldTestHarness(name)
{
  Reset();
  error= SetArgs (argc, argv);
}

RooUnfoldTestHarness2D::RooUnfoldTestHarness2D (const char* name, const char* args)
  : RooUnfoldTestHarness(name)
{
  Reset();
  const char* const argv[]= { name, args };
  error= SetArgs (2, argv, true);
}

void RooUnfoldTestHarness2D::Reset()
{
  RooUnfoldTestHarness::Reset();
  hTrainX= hTrainTrueX= hTrueX= hMeasX= hRecoX=
  hTrainY= hTrainTrueY= hTrueY= hMeasY= hRecoY= hPDFy= hTestPDFy= 0;
  dim= 2;
}

void RooUnfoldTestHarness2D::Parms (ArgVars& args)
{
  RooUnfoldTestHarness::Parms (args);
  args.SetDefault ("ntx",    30);
  args.SetDefault ("onepage", 8);
  args.Add ("ftrainy", &ftrainy,      0, "training Y PDF");
  args.Add ("ftesty",  &ftesty ,      4, "test Y PDF");
  args.Add ("nty",     &nty,         10, "#truth Y bins");
  args.Add ("nmy",     &nmy,         -1, "#measured Y bins", "nty");
  args.Add ("ylo",     &ylo,        0.0, "Y range minimum");
  args.Add ("yhi",     &yhi,       10.0, "Y range maximum");
  args.Add ("mtrainy", &mtrainy,    5.0, "training signal PDF Y mean");
  args.Add ("wtrainy", &wtrainy,    1.2, "training signal PDF Y width");
  args.Add ("btrainy", &btrainy,    0.1, "training Y PDF background fraction");
  args.Add ("mtesty",  &mtesty,     4.5, "test signal PDF Y mean");
  args.Add ("wtesty",  &wtesty,     2.5, "test signal PDF Y width");
  args.Add ("btesty",  &btesty,     0.2, "test Y PDF background fraction");
  args.Add ("effylo",  &effylo,     0.8, "efficiency at ylo");
  args.Add ("effyhi",  &effyhi,     1.0, "efficiency at yhi");
  args.Add ("rotxy",   &rotxy,      0.6, "rotation angle in XY plane");
  args.Add ("ybias",   &ybias,      1.0, "shift in Y");
  args.Add ("ysmear",  &ysmear,     0.5, "Y smearing width in bins");
}

#endif
